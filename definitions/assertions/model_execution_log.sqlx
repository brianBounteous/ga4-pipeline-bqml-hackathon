config {
  type: "incremental",
  schema: dataform.projectConfig.vars.DESTINATION_DATASET,
  description: "Audit log tracking execution of all pipeline models",
  tags: ["daily", "ga4", "core", "audit"],
  dependencies: [
    "base_events",
    "sessions",
    "dim_pages",
    "fct_page_views",
    "transactions",
    "ecommerce_items",
    "user_identity_map",
    "users"
  ], 
  bigquery: {
    partitionBy: "load_date",
    clusterBy: ["model_name", "event_date"]
  }
}

js {
  const helpers = require('includes/helper.js');
  const config = helpers.getConfig();
  const rollingRefreshDays = config.ROLLING_REFRESH_DAYS;

  const enabledModels = [
    'base_events', 'sessions', 'dim_pages', 'fct_page_views',
    'user_identity_map', 'users'
  ];
  
  if (config.HAS_ECOMMERCE) {
    enabledModels.push('transactions', 'ecommerce_items');
  }
  
  console.log(`[MODEL_EXECUTION_LOG] Tracking models: ${enabledModels.join(', ')}`);
}

-- Date spine: one row per date in the rolling refresh window
WITH date_spine AS (
  SELECT event_date
  FROM UNNEST(
    GENERATE_DATE_ARRAY(
      DATE_SUB(CURRENT_DATE(), INTERVAL ${rollingRefreshDays} DAY),
      DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY)
    )
  ) AS event_date
),

-- ============================================================================
-- Model stats: aggregate metrics per date for each model
-- ============================================================================

base_events_stats AS (
  SELECT
    event_date,
    COUNT(*) AS row_count,
    MIN(event_timestamp) AS min_event_timestamp,
    MAX(event_timestamp) AS max_event_timestamp,
    COUNT(DISTINCT session_key) AS sessions,
    COUNT(DISTINCT user_id) AS users
  FROM ${ref("base_events")}
  WHERE event_date >= DATE_SUB(CURRENT_DATE(), INTERVAL ${rollingRefreshDays} DAY)
    AND event_date < CURRENT_DATE()
  GROUP BY event_date
),

sessions_stats AS (
  SELECT
    session_date AS event_date,
    COUNT(*) AS row_count,
    MIN(session_start_timestamp) AS min_event_timestamp,
    MAX(session_end_timestamp) AS max_event_timestamp,
    COUNT(DISTINCT session_key) AS sessions,
    COUNT(DISTINCT user_id) AS users
  FROM ${ref("sessions")}
  WHERE session_date >= DATE_SUB(CURRENT_DATE(), INTERVAL ${rollingRefreshDays} DAY)
    AND session_date < CURRENT_DATE()
  GROUP BY session_date
),

dim_pages_stats AS (
  SELECT
    last_seen_date AS event_date,
    COUNT(*) AS row_count,
    CAST(NULL AS INT64) AS min_event_timestamp,
    CAST(NULL AS INT64) AS max_event_timestamp,
    CAST(NULL AS INT64) AS sessions,
    CAST(NULL AS INT64) AS users
  FROM ${ref("dim_pages")}
  WHERE last_seen_date >= DATE_SUB(CURRENT_DATE(), INTERVAL ${rollingRefreshDays} DAY)
    AND last_seen_date < CURRENT_DATE()
  GROUP BY last_seen_date
),

fct_page_views_stats AS (
  SELECT
    event_date,
    COUNT(*) AS row_count,
    CAST(NULL AS INT64) AS min_event_timestamp,
    CAST(NULL AS INT64) AS max_event_timestamp,
    COUNT(DISTINCT session_key) AS sessions,
    COUNT(DISTINCT user_id) AS users
  FROM ${ref("fct_page_views")}
  WHERE event_date >= DATE_SUB(CURRENT_DATE(), INTERVAL ${rollingRefreshDays} DAY)
    AND event_date < CURRENT_DATE()
  GROUP BY event_date
),

user_identity_map_stats AS (
  SELECT
    last_seen_date AS event_date,
    COUNT(*) AS row_count,
    CAST(NULL AS INT64) AS min_event_timestamp,
    CAST(NULL AS INT64) AS max_event_timestamp,
    CAST(NULL AS INT64) AS sessions,
    COUNT(DISTINCT user_pseudo_id) AS users
  FROM ${ref("user_identity_map")}
  WHERE last_seen_date >= DATE_SUB(CURRENT_DATE(), INTERVAL ${rollingRefreshDays} DAY)
    AND last_seen_date < CURRENT_DATE()
  GROUP BY last_seen_date
),

users_stats AS (
  SELECT
    last_seen_date AS event_date,
    COUNT(*) AS row_count,
    CAST(NULL AS INT64) AS min_event_timestamp,
    CAST(NULL AS INT64) AS max_event_timestamp,
    CAST(NULL AS INT64) AS sessions,
    COUNT(*) AS users
  FROM ${ref("users")}
  WHERE last_seen_date >= DATE_SUB(CURRENT_DATE(), INTERVAL ${rollingRefreshDays} DAY)
    AND last_seen_date < CURRENT_DATE()
  GROUP BY last_seen_date
)

${ when(config.HAS_ECOMMERCE, `
,
transactions_stats AS (
  SELECT
    event_date,
    COUNT(*) AS row_count,
    MIN(event_timestamp) AS min_event_timestamp,
    MAX(event_timestamp) AS max_event_timestamp,
    COUNT(DISTINCT session_key) AS sessions,
    COUNT(DISTINCT user_id) AS users
  FROM ${ref("transactions")}
  WHERE event_date >= DATE_SUB(CURRENT_DATE(), INTERVAL ${rollingRefreshDays} DAY)
    AND event_date < CURRENT_DATE()
  GROUP BY event_date
),

ecommerce_items_stats AS (
  SELECT
    event_date,
    COUNT(*) AS row_count,
    MIN(event_timestamp) AS min_event_timestamp,
    MAX(event_timestamp) AS max_event_timestamp,
    COUNT(DISTINCT session_key) AS sessions,
    COUNT(DISTINCT user_id) AS users
  FROM ${ref("ecommerce_items")}
  WHERE event_date >= DATE_SUB(CURRENT_DATE(), INTERVAL ${rollingRefreshDays} DAY)
    AND event_date < CURRENT_DATE()
  GROUP BY event_date
)
`)}

-- ============================================================================
-- Join date spine to each model's stats (guarantees a row per date per model)
-- ============================================================================

SELECT CURRENT_TIMESTAMP() AS load_timestamp, CURRENT_DATE() AS load_date,
  'base_events' AS model_name, d.event_date,
  COALESCE(s.row_count, 0) AS row_count, s.min_event_timestamp, s.max_event_timestamp,
  COALESCE(s.sessions, 0) AS sessions, COALESCE(s.users, 0) AS users
FROM date_spine d LEFT JOIN base_events_stats s ON d.event_date = s.event_date

UNION ALL

SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(),
  'sessions', d.event_date,
  COALESCE(s.row_count, 0), s.min_event_timestamp, s.max_event_timestamp,
  COALESCE(s.sessions, 0), COALESCE(s.users, 0)
FROM date_spine d LEFT JOIN sessions_stats s ON d.event_date = s.event_date

UNION ALL

SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(),
  'dim_pages', d.event_date,
  COALESCE(s.row_count, 0), s.min_event_timestamp, s.max_event_timestamp,
  s.sessions, s.users
FROM date_spine d LEFT JOIN dim_pages_stats s ON d.event_date = s.event_date

UNION ALL

SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(),
  'fct_page_views', d.event_date,
  COALESCE(s.row_count, 0), s.min_event_timestamp, s.max_event_timestamp,
  COALESCE(s.sessions, 0), COALESCE(s.users, 0)
FROM date_spine d LEFT JOIN fct_page_views_stats s ON d.event_date = s.event_date

UNION ALL

SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(),
  'user_identity_map', d.event_date,
  COALESCE(s.row_count, 0), s.min_event_timestamp, s.max_event_timestamp,
  s.sessions, COALESCE(s.users, 0)
FROM date_spine d LEFT JOIN user_identity_map_stats s ON d.event_date = s.event_date

UNION ALL

SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(),
  'users', d.event_date,
  COALESCE(s.row_count, 0), s.min_event_timestamp, s.max_event_timestamp,
  s.sessions, COALESCE(s.users, 0)
FROM date_spine d LEFT JOIN users_stats s ON d.event_date = s.event_date

${ when(config.HAS_ECOMMERCE, `
UNION ALL

SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(),
  'transactions', d.event_date,
  COALESCE(s.row_count, 0), s.min_event_timestamp, s.max_event_timestamp,
  COALESCE(s.sessions, 0), COALESCE(s.users, 0)
FROM date_spine d LEFT JOIN transactions_stats s ON d.event_date = s.event_date

UNION ALL

SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(),
  'ecommerce_items', d.event_date,
  COALESCE(s.row_count, 0), s.min_event_timestamp, s.max_event_timestamp,
  COALESCE(s.sessions, 0), COALESCE(s.users, 0)
FROM date_spine d LEFT JOIN ecommerce_items_stats s ON d.event_date = s.event_date
`)}